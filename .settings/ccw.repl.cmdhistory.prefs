#Thu Sep 20 17:42:36 CEST 2012
cmdhistory=[";; Switching to day1 namespace" "(println \\"apa\\")" "(big \\"apa\\" 4)" "(big \\"apa\\" 2)" "1" "(+ 1 1)" ";; Switching to day1 namespace" "(+ 1 1)" "(blaj 1)" "(blaj 2)" "(blaj 4)" "(class (1 2 3))" "(class '(1 2 3))" "(parents clojure.lang.PersistentList)" "(supers clojure.lang.PersistentList)" "(supers clojure.lang.PersistentMap)" "(class {\:a 1})" "(supers clojure.lang.PersistentArrayMap)" "(collection-type '(1 2 3))" "(collection-type {\:a 1})" "(class '(1 2 3))" "(collection-type 1)" "(class '(1 2 3))" "(collection-type '(1 2 3))" "\:\:collection" "\:List" "\:list" "\:\:list" "(list? '(1 2 3))" "(unless (< 1 2)\\n        (println \\"false\\")\\n        (println \\"true\\"))" ";; Switching to day1 namespace" "(unless (< 1 2)\\n        (println \\"false\\")\\n        (println \\"true\\"))" "(macroexpand unless)" "(macroexpand (unless (< 1 2)\\n        (println \\"false\\")\\n        (println \\"true\\")))" "(unless (< 1 2)\\n        (println \\"false\\")\\n        (println \\"true\\"))" ";; Switching to day1 namespace" "(unless (< 1 2)\\n        (println \\"false\\")\\n        (println \\"true\\"))" "(macroexpand (unless (< 1 2)\\n        (println \\"false\\")\\n        (println \\"true\\")))" "(macroexpand '(unless (< 1 2)\\n        (println \\"false\\")\\n        (println \\"true\\")))" "(unless (< 1 2)\\n        (println \\"false\\")\\n        (println \\"true\\"))" "(unless (true)\\n        (println \\"false\\")\\n        (println \\"true\\"))" "(unless true\\n        (println \\"false\\")\\n        (println \\"true\\"))" "(unless false\\n        (println \\"false\\")\\n        (println \\"true\\"))" "*8" "(makeSound (Dog. \\"fido\\"))" "(name (Dog. \\"fido\\"))" "(ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \\"classes\\"] (clojure.core/compile 'day1)))" ";; Switching to day1 namespace" "(myName (Dog. \\"fido\\"))" "(grej 1)" "(grej (Dog. \\"fido\\"))" "(alter (ref 4))" "(ref 4)" "(let [a (ref 4)]\\n  a)" "(let [a (ref 4)]\\n  @a)" "(let [accounts (ref [1 2 3 4 5])]\\n  (dosync\\n    (alter accounts (fn [amounts] [1])))\\n  @accounts)" "(update-in [1 2 3] 1 5)" "(update-in [1 2 3] 1 (fn [a] (+ a 1)))" "(update-in [1 2 3] [1] (fn [a] (+ a 1)))" "(update-in [1 2 3] [1 2] (fn [a] (+ a 1)))" "(update-in [1 2 3] [1] (fn [a] (+ a 1)))" "(update-in [1 2 3] [0 1] (fn [a] (+ a 1)))" "(update-in [1 2 3] [0] (fn [a] (+ a 1)))" "(update-in [1 2 3] [0] \#(+ % 1)))" "(update-in [1 2 3] [0] \#(+ % 1))" "(update-in [1 2 3] [0] (+ _ 1))" "(update-in [1 2 3] [0] (+ % 1))" "(update-in [1 2 3] [0] \#(+ % 1))" "(update-in [1 2 3] [0] (inc))" "(update-in [1 2 3] [0] inc)" "(update-in [1 2 3] [0] dec)" "(map [1 2 3] dec)" "(myCount '(1 2 3))" "(myCount '())" "(myCount '(1 2 3))" "(myCount1 '(1 2 3))" "(myCount1 '(1 2 3 4))" "(myCount1 (repeat 1))" "(myCount2'(1 2 3 4))" "(myCount2 \\n  '(1 2 3 4))" "(myCount2 '())" "(myCount2 '(1 2 3\\n              ))" "(myCount2 (repeat 1))" "(myCount3 '(1 2 3\\n              ))" "(myCount3\\n  (repeat 1))" "(myCount2\\n  (repeat 1))" "(myCount3\\n  (repeat 1))" ";; Switching to day1 namespace" "(use 'clojure.algo.monads)" "(nil? nil)" "(nil? '())" "(combine '(1 2 3) '(4 5 6))" "(concat '(1 2 3) '(4 5 6))" "(myFlatten '(1 2 3))" "(myFlatten '(\\n              ))" "(myFlatten '(1))" "(cons 1 '())" "(def seq '(1 2 3))" "(cons (first '(1)) (rest '(1)))" "(myFlatten '(1))" "(myFlatten '(1 2 3))" "(myFlatten '('() 1 2 3))" "(myFlatten '(1 2 3 4 5))" "(myFlatten '('(1 2 3) 1 2 3 4 5))" "(myFlatten '((1 2 3) 1 2 3 4 5))" "(myFlatten '((1 (2 3)) 1 2 3 4 5))" "(myFlatten '((1 (2 3)) 1 2 3 (4 5)))" "(\= \:hej \:hej)" "(customer \\"cust\\" (ref \:empty) (ref '()))" "(main)" "main" "(main)" ";; Switching to clojure4 namespace" "(\= [2 4] (let [[a b c d e f g] (range)] c e))" "(\= [2 4] (let [[a b c d e f g] (range)] [b d]))" "(\= [2 4] (let [[a b c d e f g] (range)] [c e]))" "(unit-test (\= 1 1))" "(macroexpand '(unit-test (\= 1 1)))" "(problem52)" "(problem44)" "(butlast '(1 2 3 4))" "(class (butlast '(1 2 3 4)))" "(rotate44 1 '(1 2 3))" "(rotate44 2 '(1 2 3))" "(rotate44 1 '(1 2 3))" "(rotate44 2 '(1 2 3))" "(problem44)" "(rotate44 2 '(1 2 3))" "(rotate44 2 '(1 2 3 4 5))" "(problem44)" "(conj '(1 2 3) 4)" "(problem44)" "(conj '(1 2 3) 4)" "(conj [1 2 3] 4)" "(class [1 2 3])" "(class (1 2 3))" "(class '(1 2 3))" "(class '(\:1 \:2 \:3))" "(conj '(\:1 \:2 \:3) \:4)" "(add-last \:4 '(\:1 \:2 \:3))" "(problem44)" "(rotate44 2 '(1 2 3 4 5))" "(problem44)" "(rotate44 1 '(1 2 3))" "((fn hej [e l]\\r\\n                    (if (empty? l) \\r\\n                      (list e)\\r\\n                      (cons (first l) (hej e (rest l))))) 1 '(1 2 3 4))" "((fn hej [e l]\\r\\n                    (if (empty? l) \\r\\n                      (list e)\\r\\n                      (cons (first l) (hej e (rest l))))) 7 '(1 2 3 4))" "((fn hej [e l]\\r\\n                    (if (empty? l) \\r\\n                      (list e)\\r\\n                      (cons (first l) (hej e (rest l))))) 7 '())" "(rotate44 1 '(1 2 3))" "(rotate44 1 '(1))" "(rotate44 0 '(1))" "(rotate44 -1 '(1))" "(rotate44 -2 '(1))" "(rotate44 -2 '(1 2))" "(rotate44 -2 '(1 2 3))" "(rotate44 1 '(1 2 3))" "(rotate44 2 '(1 2 3))" "(problem44)" "(problem55)" "(mycount 1)" "(mycount 1 1)" "(mycount 1)" "(mycount 1 1)" "(update-in {} [\:foo] inc)" "(update-in {\:foo 1} [\:foo] inc)" "((fnil inc 0) nil)" "((fnil inc 34) nil)" "(update-in {} [\:foo] inc)" "(update-in {} [\:foo] 1)" "(update-in {} [\:foo] (fn [current] 1))" "(problem55)" "(mycount '(1 1 1))" "(problem55)" "(mycount (repeat 1))" "((fn [list & rest]\\n  (do\\n    (println list)\\n    (println rest))) 1 2 3 4 5)" "((fn [list rest]\\n  (do\\n    (println list)\\n    (println rest))) 1 2 3 4 5)" "((fn [& rest]\\n  (do\\n    (println rest))) 1 2 3 4 5)" "(macroexpand '(u-test 1 2 3))" "(defn problem52 []\\n  (unit-test (\= [2 4] (let [[a b c d e f g] (range)] [c e]))))" "(macroexpand '(u-test 1 2 3))" "(macroexpand '(u-test (\= 1 2) (\= 1 1)))" "(do (\= 1 2) (\= 1 1))" "(do '(\= 1 2) '(\= 1 1))" "(macroexpand '(u-test (\= 1 2) (\= 1 1)))" "(macroexpand-1 '(u-test (\= 1 2) (\= 1 1)))" "(macroexpand '(u-test (\= 1 2) (\= 1 1)))" "(u-test (\= 1 2) (\= 1 1))" "((u-test (\= 1 2) (\= 1 1)))" "(u-test (\= 1 2) (\= 1 1))" "(eval (u-test (\= 1 2) (\= 1 1)))" "(macroexpand '(u-test (\= 1 2) (\= 1 1)))" "(u-test (\= 1 2) (\= 1 1))" "(macroexpand '(u-test (\= 1 2) (\= 1 1)))" "(macroexpand-1 '(u-test (\= 1 2) (\= 1 1)))" "(macroexpand-2 '(u-test (\= 1 2) (\= 1 1)))" "(macroexpand '(u-test (\= 1 2) (\= 1 1)))" "(u-test (\= 1 2) (\= 1 1))" "(macroexpand '(u-test (\= 1 2) (\= 1 1)))" "(u-test (\= 1 2) (\= 1 1))" "(macroexpand '(u-test (\= 1 2) (\= 1 1)))" "(macroexpand-1'(u-test (\= 1 2) (\= 1 1)))" "(u-test (\= 1 2) (\= 1 1))" "(macroexpand-1'(u-test (\= 1 2) (\= 1 1)))" "(macroexpand-1 '(u-test (\= 1 2) (\= 1 1)))" "(defmacro test [foo] '(list 1))" "(defmacro foo [foo] '(list 1))" "(do \\n  (defmacro foo [foo] '(list 1))\\n  (foo 1))" "(do \\n  (defmacro foo [foo] '(1))\\n  (foo 1))" "(do \\n  (defmacro foo [foo] '(list 1))\\n  (foo 1))" "(do \\n  (defmacro foo [foo] '(list foo))\\n  (foo 1))" "(do \\n  (defmacro foo [foo] '(list 'foo))\\n  (foo 1))" "(do \\n  (defmacro foo [foo] '(list ~foo))\\n  (foo 1))" "(do \\n  (defmacro foo [bar] '(list ~bar))\\n  (foo 1))" "(do \\n  (defmacro foo [bar] '(list bar))\\n  (foo 1))" "(do \\n  (defmacro foo [bar] '(list bar\#))\\n  (foo 1))" "(do \\n  (defmacro foo [bar] `(list bar\#))\\n  (foo 1))" "(do \\n  (defmacro foo [bar] `(list bar))\\n  (foo 1))" "(do \\n  (defmacro foo [bar] `(list ~bar))\\n  (foo 1))" "(u-test (\= 1 2) (\= 1 1))" "(macroexpand-1 '(u-test (\= 1 2) (\= 1 1)))" "(macroexpand '(u-test (\= 1 2) (\= 1 1)))" "(u-test (\= 1 2) (\= 1 1))" "(macroexpand '(u-test (\= 1 2) (\= 1 1)))" "(u-test (\= 1 2) (\= 1 1))" "(macroexpand '(u-test (\= 1 2) (\= 1 1)))" "(u-test (\= 1 2) (\= 1 1))" ";; Switching to clojure4 namespace" "(u-test (\= 1 2) (\= 1 1))" "(do (println '(\= 1 2)))" "(u-test (\= 1 2) (\= 1 1))" "(macroexpand '(u-test (\= 1 2) (\= 1 1)))" "(u-test (\= 1 2) (\= 1 1))" "(macroexpand '(u-test\\r\\n  (\= (myrotate 2 [1 2 3 4 5]) '(3 4 5 1 2))\\r\\n  (\= (myrotate -2 [1 2 3 4 5]) '(4 5 1 2 3))\\r\\n  (\= (myrotate 6 [1 2 3 4 5]) '(2 3 4 5 1))\\r\\n  (\= (myrotate 1 '(\:a \:b \:c)) '(\:b \:c \:a))\\r\\n  (\= (myrotate -4 '(\:a \:b \:c)) '(\:c \:a \:b))))" "(u-test\\r\\n  (\= (myrotate 2 [1 2 3 4 5]) '(3 4 5 1 2))\\r\\n  (\= (myrotate -2 [1 2 3 4 5]) '(4 5 1 2 3))\\r\\n  (\= (myrotate 6 [1 2 3 4 5]) '(2 3 4 5 1))\\r\\n  (\= (myrotate 1 '(\:a \:b \:c)) '(\:b \:c \:a))\\r\\n  (\= (myrotate -4 '(\:a \:b \:c)) '(\:c \:a \:b)))" "(u-test (\= 1 1))" "(macroexpand (u-test (\= 1 1)))" "(macroexpand '(u-test (\= 1 1)))" "(do ((if (clojure.core/not (\= 1 1)) (clojure.core/println (clojure.core/str (quote (\= 1 1)) \\" failed\\")))) \:done)" "(do ((if (not (\= 1 1)) (println (str (quote (\= 1 1)) \\" failed\\")))) \:done)" "(do ((if (not (\= 1 1)) (println (str (quote ('\= 1 1)) \\" failed\\")))) \:done)" "(do ((if (not (\= 1 1)) (println (str (quote (\= 1 1)) \\" failed\\")))) \:done)" "(do ((if (not (\= 1 1)) (println (str \\"1\\" \\" failed\\")))) \:done)" "(do ((if (not (\= 1 1)) (println (str \\"failed\\")))) \:done)" "(do ((if (not (\= 1 1)) (println \\"failed\\"))) \:done)" "(do ((if (not (\= 1 1)) (println \\"failed\\"))))" "(do (if (not (\= 1 1)) (println \\"failed\\")))" "(macroexpand '(u-test (\= 1 1)))" "(u-test (\= 1 1))" "(macroexpand '(u-test (\= 1 1)))" "(do ((1)))" "(do ((inc 1)))" "(u-test (\= 1 1))" "(macroexpand '(u-test (\= 1 1)))" "(do (if (clojure.core/not (\= 1 1)) (clojure.core/println (clojure.core/str (quote (\= 1 1)) \\" failed\\"))) \:done)" "(do ((if (clojure.core/not (\= 1 1)) (clojure.core/println (clojure.core/str (quote (\= 1 1)) \\" failed\\")))) \:done)" "(if (clojure.core/not (\= 1 1)) (clojure.core/println (clojure.core/str (quote (\= 1 1)) \\" failed\\")))" "(nil)" "(do ((nil)) \:done)" "(do ((if (clojure.core/not (\= 1 1)) (clojure.core/println (clojure.core/str (quote (\= 1 1)) \\" failed\\")))) \:done)" "(do ((if (clojure.core/not (\= 1 1)) (clojure.core/println (clojure.core/str (quote (\= 1 1)) \\" failed\\")))))" "(do ((if (clojure.core/not (\= 1 1)) (println \\"hej\\")))))" "(do ((if (clojure.core/not (\= 1 1)) (println \\"hej\\"))))" "(do ((if (not (\= 1 1)) (println \\"hej\\"))))" "(if (not (\= 1 1)) (println \\"hej\\"))" "(do ((if (not (\= 1 1)) (println \\"hej\\"))))" "(do ((if (not (\= 1 1)) nil)))" "(do ((if (\= 1 1) nil)))" "(do ((nil)))" "(do ((if (\= 1 1) nil)))" "(if (\= 1 1) nil)" "(macroexpand '(u-test (\= 1 1)))" "(u-test (\= 1 1))" "(u-test (\= 1 2))" "(u-test\\r\\n  (\= (myrotate 2 [1 2 3 4 5]) '(3 4 5 1 2))\\r\\n  (\= (myrotate -2 [1 2 3 4 5]) '(4 5 1 2 3))\\r\\n  (\= (myrotate 6 [1 2 3 4 5]) '(2 3 4 5 1))\\r\\n  (\= (myrotate 1 '(\:a \:b \:c)) '(\:b \:c \:a))\\r\\n  (\= (myrotate -4 '(\:a \:b \:c)) '(\:c \:a \:b)))" "(println \\"hej\\" \\"hopp\\")" "(macroexpand '(u-test\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n  (\= (myrotate -4 '(\:a \:b \:c)) '(\:c \:a \:b))))" "(macroexpand '(u-test \\"hej\\" (\= (myrotate -4 '(\:a \:b \:c)) '(\:c \:a \:b))))" "(macroexpand '(u-test (\= 1 1)))" "(macroexpand '(u-test \\"\\" (\= 1 1)))" "(macroexpand '(u-test \\"hej\\" (\= (myrotate -4 '(\:a \:b \:c)) '(\:c \:a \:b))))" "(macroexpand '(u-test \\"\\" (\= 1 1)))" "(u-test \\"problem55\\"\\r\\n  (\= (my-count [1 1 2 3 2 1 1]) {1 4, 2 2, 3 1})\\r\\n  (\= (my-count [\:b \:a \:b \:a \:b]) {\:a 2, \:b 3})\\r\\n  (\= (my-count '([1 2] [1 3] [1 3])) {[1 2] 1, [1 3] 2}))" "(macroexpand '(u-test \\"problem55\\"\\r\\n  (\= (my-count [1 1 2 3 2 1 1]) {1 4, 2 2, 3 1})\\r\\n  (\= (my-count [\:b \:a \:b \:a \:b]) {\:a 2, \:b 3})\\r\\n  (\= (my-count '([1 2] [1 3] [1 3])) {[1 2] 1, [1 3] 2})))" "(macroexpand-1 '(u-test \\"problem55\\"\\r\\n  (\= (my-count [1 1 2 3 2 1 1]) {1 4, 2 2, 3 1})\\r\\n  (\= (my-count [\:b \:a \:b \:a \:b]) {\:a 2, \:b 3})\\r\\n  (\= (my-count '([1 2] [1 3] [1 3])) {[1 2] 1, [1 3] 2})))" "(reduce (fn [a b] a) '(1 2 3))" "(reduce (fn [a b] b) '(1 2 3))" "(reduce (fn [a b] (+ a b)) 0 '(1 2 3))" "(reduce (fn [a b] (+ a b)) 1 '(1 2 3))" "(reduce (fn [total ele] (and total ele) true '(true true true))" "(reduce (fn [total ele] (and total ele) true '(true true true)))" "(reduce (fn [total ele] (and total ele)) true '(true true true))" "(reduce (fn [total ele] (and total ele)) true '(true false true))" "(reduce and true '(true false true))" "(reduce \#(and %) true '(true false true))" "(reduce \#(and % %) true '(true false true))" "(macroexpand '(u-test \\"\\" (\= 1 1)))" "(macroexpand-2\\n  '(u-test \\"\\" (\= 1 1)))" "(macroexpand-1 '(u-test \\"\\" (\= 1 1)))" "(do (clojure.core/println \\"Executing\\" \\"\\") (clojure.core/reduce (clojure.core/fn [res__5654__auto__ test__5655__auto__] (clojure.core/and res__5654__auto__ (clojure4/execute-test test__5655__auto__))) true ((\= 1 1))) (clojure.core/println \\"Done\\"))" "(do (clojure.core/reduce (clojure.core/fn [res__5654__auto__ test__5655__auto__] (clojure.core/and res__5654__auto__ (clojure4/execute-test test__5655__auto__))) true ((\= 1 1))) (clojure.core/println \\"Done\\"))" "(do (reduce (fn [res test] (and res (execute-test test))) true ((\= 1 1))))" "(do (reduce (fn [res test] (and res (execute-test test))) true '((\= 1 1))))" "(macroexpand-1 '(u-test \\"\\" (\= 1 1)))" "\\n(u-test \\"\\" (\= 1 1))" "(macroexpand-1 '(u-test \\"\\" (\= 1 1)))" "'((\= 1 1))" "'((\= 1 1) (\= 1 2))" "(reduce (fn [tot test] (and tot test) true '((\= 1 1) (\= 1 2))" "(reduce (fn [tot test] (and tot test) true '((\= 1 1) (\= 1 2))))" "(reduce (fn [tot test] (and tot test)) true '((\= 1 1) (\= 1 2)))" "(and '(\= 1 2) true)" "(reduce (fn [tot test] (println test)) true '((\= 1 1) (\= 1 2)))" "(reduce (fn [tot test] (println (test))) true '((\= 1 1) (\= 1 2)))" "(reduce (fn [tot test] (println (eval test))) true '((\= 1 1) (\= 1 2)))" "(macroexpand-1 '(u-test \\"\\" (\= 1 1)))" "(\= 1 1)" "((\= 1 1))" "(macroexpand-1 '(u-test \\"\\" (\= 1 1)))" "(macroexpand-1 '(u-test \\"\\" (\= 1 1) (\= 1 2)))" "(macroexpand '(u-test \\"problem46\\"\\r\\n  (\= 3 ((my-flip-args nth) 2 [1 2 3 4 5]))\\r\\n  (\= true ((my-flip-args >) 7 8))\\r\\n  (\= 4 ((my-flip-args quot) 2 8))\\r\\n  (\= [1 2 3] ((my-flip-args take) [1 2 3 4 5] 3))))" "(clojure4/run-tests \\"problem46\\" (\= 3 ((my-flip-args nth) 2 [1 2 3 4 5])) (\= true ((my-flip-args >) 7 8)) (\= 4 ((my-flip-args quot) 2 8)) (\= [1 2 3] ((my-flip-args take) [1 2 3 4 5] 3)))" "(clojure4/run-tests \\"problem46\\" '(\= 3 ((my-flip-args nth) 2 [1 2 3 4 5])) (\= true ((my-flip-args >) 7 8)) (\= 4 ((my-flip-args quot) 2 8)) (\= [1 2 3] ((my-flip-args take) [1 2 3 4 5] 3)))" "(u-test \\"test\\" (\= 1 2) (throw Exception) (\= 1 1))" "(u-test \\"test\\" (\= 1 2) (throw (.Exception)) (\= 1 1))" "(u-test \\"test\\" (\= 1 2) (throw (Throwable. \\"error\\")) (\= 1 1))" "(macroexpand '(u-test \\"test\\" (\= 1 2) (throw (Throwable. \\"error\\")) (\= 1 1)))" "((\= 1 2) (throw (Throwable. \\"error\\")) (\= 1 1)" "((\= 1 2) (throw (Throwable. \\"error\\")) (\= 1 1))" "(macroexpand '(u-test \\"test\\" (\= 1 2) (throw (Throwable. \\"error\\")) (\= 1 1)))" "(quote ((\= 1 2) (throw (Throwable. \\"error\\")) (\= 1 1)))" "(macroexpand '(u-test \\"test\\" (\= 1 2) (throw (Throwable. \\"error\\")) (\= 1 1)))" "(quote (\= 1 2) (throw (Throwable. \\"error\\")) (\= 1 1))" "('(\= 1 2) (throw (Throwable. \\"error\\")) (\= 1 1))" "(quote (\= 1 2) (throw (Throwable. \\"error\\")) (\= 1 1))" "(' (\= 1 2) (throw (Throwable. \\"error\\")) (\= 1 1))" "(quote (\= 1 2))" "(quote (\= 1 2) (\= 1 1))" "(macroexpand '(u-test \\"test\\" (\= 1 2) (throw (Throwable. \\"error\\")) (\= 1 1)))" "(quote ((\= 1 2) (throw (Throwable. \\"error\\")) (\= 1 1))" "(quote ((\= 1 2) (throw (Throwable. \\"error\\")) (\= 1 1)))" "(u-test \\"test\\" (\= 1 2) (throw (Throwable. \\"error\\")) (\= 1 1))" "Exception" "(u-test \\"test\\" (\= 1 2) (throw (Exception. \\"error\\")) (\= 1 1))" "(eval '(throw (Exception. \\"error\\")))" "(u-test \\"test\\" (\= 1 2) (throw (Exception. \\"error\\")) (\= 1 1))" "(u-test \\"test\\" (\= 1 1) (throw (Exception. \\"error\\")) (\= 1 1))" "(u-test \\"test\\" (\= 1 2) (throw (Exception. \\"error\\")) (\= 1 1))" "(u-test \\"test\\" (\= 1 1) (throw (Exception. \\"error\\")) (\= 1 1))" "(u-test \\"test\\" (\= 1 2) (throw (Exception. \\"error\\")) (\= 1 1))" "(u-test \\"test\\" (\= 1 1) (throw (Exception. \\"error\\")) (\= 1 1))" "(u-test \\"test\\" (\= 1 1)  (\= 1 1))" "(u-test \\"test\\" (\= 1 1) (throw (Exception. \\"error\\")) (\= 1 1))" "(u-test \\"test\\" (\= 1 1) (\= 1 1))" "(\= 3 ((my-flip-args nth) 2 [1 2 3 4 5]))" "'(\= 3 ((my-flip-args nth) 2 [1 2 3 4 5]))" "(eval '(\= 3 ((my-flip-args nth) 2 [1 2 3 4 5])))" "(unit-test \\"test\\" (eval test))" "(unit-test \\"test\\" (eval test1))" "(unit-test \\"test\\" (eval test))" "(unit-test \\"test\\" (eval test1))" "(interleave (range 9))" "(interleave (range 9) (range 9))" "(interleave (range 9) (range 9 11))" "(zip '(\:a \:b \:c) '(1 2 3))" "(zip-map\\n  '(\:a \:b \:c) '(1 2 3))" "(zipmap\\n  '(\:a \:b \:c) '(1 2 3))" "(for [x (range 3)] x)" "(for [x (range 3)] '())" "(my-rev-interleave '(1 2 3) 5)" "(reduce (fn [t e] t) 0 '(1 2 3))" "(reduce (fn [t e] t) '(() ()) '(1 2 3 4))" "(reduce (fn [t e] (cons e (first t))) '(() ()) '(1 2 3 4))" "(reduce (fn [t e] (first t)) '(() ()) '(1 2 3 4))" "(reduce (fn [t e] (first t)) '((1) ()) '(1 2 3 4))" "(reduce (fn [t e] (first t)) '('(1) ()) '(1 2 3 4))" "(reduce (fn [t e] (first t)) '((1) ()) '(1 2 3 4))" "(reduce (fn [t e] (first t)) '('(1) ()) '(1 2 3 4))" "(reduce (fn [t e] (first t)) '((1 2) ()) '(1 2 3 4))" "(reduce (fn [t e] t) '((1 2) ()) '(1 2 3 4))" "(reduce (fn [t e] (cons e (first t)) '(() ()) '(1 2 3 4)))" "(reduce (fn [t e] (cons e (first t))\\n          '(() ()) '(1 2 3 4)))" "(reduce (fn [t e] (cons e (first t))) '(() ()) '(1 2 3 4))" "(reduce (fn [[f &] e] (concat (last (cons e (first t))) '(() ()) '(1 2 3 4))" "(let ([a b c] '(1 2 3))\\n  a)" "(let ([a b c] [1 2 3])\\n  a)" "(let [[a b c] [1 2 3]]\\n  a)" "(let [[a & b c] [1 2 3]]\\n  a)" "(let [[a & c] [1 2 3]]\\n  c)" "(let [[a & c d] [1 2 3]]\\n  c)" "(reduce (fn [[h & t] e] (concat t (cons e h)) '(() ()) '(1 2 3 4))" "(reduce (fn [[h & t] e] (concat t (cons e h))) '(() ()) '(1 2 3 4))" "(reduce (fn [[h & t] e] (concat t ((cons e h)))) '(() ()) '(1 2 3 4))" "(reduce (fn [[h & t] e] (concat t (cons e h))) '(() ()) '(1 2 3 4))" "(concat '(()) '((1)))" "(reduce (fn [[h & t] e] (concat t (list (cons e h)))) '(() ()) '(1 2 3 4))" "(reduce (fn [[h & t] e] (concat t (vec (conj e h)))) '(() ()) '(1 2 3 4))" "(reduce (fn [[h & t] e] (concat t (vec (conj h e)))) '(() ()) '(1 2 3 4))" "(reduce (fn [[h & t] e] (concat t (vec (conj e h)))) '(() ()) '(1 2 3 4))" "(reduce (fn [[h & t] e] (concat t (vec (conj e h)))) [[][]] '(1 2 3 4))" "(reduce (fn [[h & t] e] (concat t (list (cons e h)))) '(() ()) '(1 2 3 4))" "(reduce (fn [[h & t] e] (concat t (list (conj e h)))) '(() ()) '(1 2 3 4))" "(reduce (fn [[h & t] e] (concat t (list (cons e h)))) '(() ()) '(1 2 3 4))" "(reduce (fn [[h & t] e] (concat t (list (conj h e)))) '(() ()) '(1 2 3 4))" "(reduce (fn [[h & t] e] (concat t (vec (conj h e)))) '(() ()) '(1 2 3 4))" "(reduce (fn [[h & t] e] (concat t (conj h e))) '(() ()) '(1 2 3 4))" "(reduce (fn [[h & t] e] (concat t (vec (conj h e)))) '(() ()) '(1 2 3 4))" "(conj '() 1)" "(vec (conj '() 1))" "(vec (conj [] 1))" "[(conj [] 1))]" "[(conj [] 1)]" "(concat [[1][2]] [3]" "(concat [[1][2]] [3])" "(concat [[1][2]] [[3]])" "(reduce (fn [[h & t] e] (concat t [(conj h e)])) [[][]] '(1 2 3 4))" "(for [x (range n)] '())" "(for [x (range 1)] '())" "[for [x (range 1)] '()]" "(my-rev-interleave '(1 2 3 4) 2)" "(partition 2 '(1 2 3 4))" "(vector (partition 2 '(1 2 3 4)))" "(apply map vector (partition 2 '(1 2 3 4)))" "(map vector (partition 2 '(1 2 3 4)))" "(group-by class [1 \:a 2 \:b])" "(vals (group-by class [1 \:a 2 \:b]))" "(-> 1 inc)" "(-> 1 inc inc inc)" "(-> 1 inc inc dec)" "(-> '(1 2 3 4) (take 2))" "(--> '(1 2 3 4) (take 2))" "(\=> '(1 2 3 4) (take 2))" "(->> '(1 2 3 4) (take 2))" "(update-in {} [\:key] 0)" "(update-in {} [\:key] \#(1))" "(update-in {} [\:key] (fn [_] 1))" "(or true (println \\"hej\\"))" "(or false (println \\"hej\\"))" "(or false (conj \:a \#{}))" "(or false (conj \#{} \:a))" "(if (or false (conj \#{} \:a)) (println \\"hej\\"))" "(my-remove-dup '(1 2 3 4))" "(filter \#(\= 1 %) '(1 2 3 4))" "(def foo \#{})" "(conj foo 1)" "foo" "(let [a {}]\\n  (do\\n    (update-in a [\:key] (fn [_] 1))\\n    (println a)))" "(let [a {}]\\n  (do\\n    (println (update-in a [\:key] (fn [_] 1)))\\n    (println a)))" "(my-remove-dup '(1 2 3 4))" "(my-remove-dup '(1 2 3 4 2))" "(fn [] (let [a (transient '())] (conj a 1) a))" "((fn [] (let [a (transient '())] (conj a 1) a)))" "((fn [] (let [a (transient '())] (conj\! a 1) a)))" "((fn [] (let [a (transient '())] (conj\! a 1) (persistent\! a))))" "((fn [] (let [a (transient ())] (conj\! a 1) (persistent\! a))))" "((fn [] (let [a (transient [])] (conj\! a 1) (persistent\! a))))" "((fn [] (let [a (transient \#{})] (conj\! a 1) (persistent\! a))))" "(my-remove-dup '(1 2 3 4 2))" "(transient [1 2 3])" "(str (transient [1 2 3]))" "(contains? (transient {1 2 3}) 2)" "(contains? (transient \#{1 2 3}) 2)" "(contains? (transient \#{1 2 3}) 3)" "(contains? \#{1 2 3} 3)" "(some \= '(1 2 3))" "(some not'(1 2 3))" "(some boolean '(1 2 3))" "(some (partial \= 1) '(1 2 3))" "(some (partial \= 4) '(1 2 3))" "(some (partial \= 3) '(1 2 3))" "(some (partial \= 56) '(1 2 3))" "(if (not (some (partial \= 56) '(1 2 3))) (println \\"hej\\"))" "(if (not (some (partial \= 1) '(1 2 3))) (println \\"hej\\"))" "(if (not (some \= '(1 2 3))) (println \\"hej\\"))" "(some \= '(1 2 3))" "(\= 1)" "(\=)" "(\= 1)" "(\= 1 2)"]
eclipse.preferences.version=1
